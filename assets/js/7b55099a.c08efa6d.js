"use strict";(self.webpackChunkneutron=self.webpackChunkneutron||[]).push([[7677],{3905:(e,t,r)=>{r.d(t,{Zo:()=>u,kt:()=>y});var n=r(7294);function o(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function i(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function a(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?i(Object(r),!0).forEach((function(t){o(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):i(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function c(e,t){if(null==e)return{};var r,n,o=function(e,t){if(null==e)return{};var r,n,o={},i=Object.keys(e);for(n=0;n<i.length;n++)r=i[n],t.indexOf(r)>=0||(o[r]=e[r]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)r=i[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(o[r]=e[r])}return o}var s=n.createContext({}),l=function(e){var t=n.useContext(s),r=t;return e&&(r="function"==typeof e?e(t):a(a({},t),e)),r},u=function(e){var t=l(e.components);return n.createElement(s.Provider,{value:t},e.children)},d="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},f=n.forwardRef((function(e,t){var r=e.components,o=e.mdxType,i=e.originalType,s=e.parentName,u=c(e,["components","mdxType","originalType","parentName"]),d=l(r),f=o,y=d["".concat(s,".").concat(f)]||d[f]||p[f]||i;return r?n.createElement(y,a(a({ref:t},u),{},{components:r})):n.createElement(y,a({ref:t},u))}));function y(e,t){var r=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=r.length,a=new Array(i);a[0]=f;var c={};for(var s in t)hasOwnProperty.call(t,s)&&(c[s]=t[s]);c.originalType=e,c[d]="string"==typeof e?e:o,a[1]=c;for(var l=2;l<i;l++)a[l]=r[l];return n.createElement.apply(null,a)}return n.createElement.apply(null,r)}f.displayName="MDXCreateElement"},8082:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>s,contentTitle:()=>a,default:()=>p,frontMatter:()=>i,metadata:()=>c,toc:()=>l});var n=r(7462),o=(r(7294),r(3905));const i={},a="Liquidity Iteration",c={unversionedId:"neutron/modules/dex/overview/concepts/liquidity-iteration",id:"neutron/modules/dex/overview/concepts/liquidity-iteration",title:"Liquidity Iteration",description:"When swapping through liquidity via a Swap, Multi-Hop Swap, or a Taker Limit Order we iterate through the available tick liquidity to fill the swap order. Liquidity is always iterated through in order of best to worst price. In the case of swapping Token0 (tokenIn) for Token1 (tokenOut) we iterate through tickIndexes left to right (eg. -1, 0, 1, 2...) and for Token1 for Token0 we iterate from right to left (eg. 2, 1, 0, -1\u2026) For each swap we completely exhaust the available reserves before moving onto the next tick. For TickLiquidity instances at the same TickIndex they are iterated through in a deterministic order as follows. PoolReserves In ascending TrancheKey order",source:"@site/docs/neutron/modules/dex/overview/concepts/liquidity-iteration.md",sourceDirName:"neutron/modules/dex/overview/concepts",slug:"/neutron/modules/dex/overview/concepts/liquidity-iteration",permalink:"/neutron/modules/dex/overview/concepts/liquidity-iteration",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"docs",previous:{title:"AMMs and Orderbooks",permalink:"/neutron/modules/dex/overview/concepts/amms-and-orderbooks"},next:{title:"Liquidity Pools",permalink:"/neutron/modules/dex/overview/concepts/liquidity-pools"}},s={},l=[],u={toc:l},d="wrapper";function p(e){let{components:t,...r}=e;return(0,o.kt)(d,(0,n.Z)({},u,r,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"liquidity-iteration"},"Liquidity Iteration"),(0,o.kt)("p",null,"When swapping through liquidity via a Swap, Multi-Hop Swap, or a Taker Limit Order we iterate through the available tick liquidity to fill the swap order. Liquidity is always iterated through in order of best to worst price. In the case of swapping Token0 (tokenIn) for Token1 (tokenOut) we iterate through tickIndexes left to right (eg. -1, 0, 1, 2...) and for Token1 for Token0 we iterate from right to left (eg. 2, 1, 0, -1\u2026) For each swap we completely exhaust the available reserves before moving onto the next tick. For TickLiquidity instances at the same ",(0,o.kt)("inlineCode",{parentName:"p"},"TickIndex")," they are iterated through in a deterministic order as follows. PoolReserves: In Ascending ",(0,o.kt)("inlineCode",{parentName:"p"},"Fee")," order LimitOrderTranches: In ascending ",(0,o.kt)("inlineCode",{parentName:"p"},"TrancheKey")," order"))}p.isMDXComponent=!0}}]);